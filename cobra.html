<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jogo da Cobra — Cabeça de Robô busca o "v"</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:18px}
    canvas{background:#0b1220;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.6)}
    .hud{color:#e6eef8;display:flex;gap:12px;align-items:center}
    .controls{color:#cbd6e6;font-size:14px}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2b7bff;color:#fff;cursor:pointer}
    button:active{transform:translateY(1px)}
    small{color:#9fb0d0}
  </style>
</head>
<body>
  <div class="wrap">
    <h2 style="margin:0;color:#e6eef8">Cobra — Cabeça de Robô persegue o "v"</h2>
    <div class="hud">
      <div>Score: <span id="score">0</span></div>
      <div class="controls">use as setas ⬅️⬆️⬇️➡️ ou A W S D</div>
      <button id="restart">Reiniciar</button>
    </div>
    <canvas id="game" width="600" height="600"></canvas>
    <small>Dica: quando o robo pega o "v" a cobra cresce.</small>
  </div>

<script>
// Jogo da Cobra com cabeça de robô que persegue o alvo chamado "v"
// Código simples, comentado e pronto para executar em qualquer navegador moderno.

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const restartBtn = document.getElementById('restart');

const TILE = 20; // tamanho do bloco
const COLS = canvas.width / TILE;
const ROWS = canvas.height / TILE;

let snake; // array de segmentos: {x,y}
let dir;   // direção: {x,y}
let nextDir; // para evitar virar 180° instantâneo
let vo;    // posição do alvo
let running = false;
let score = 0;
let speed = 100; // ms por frame (diminui para ficar mais rápido)
let loopId;

function reset(){
  snake = [ {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)} ];
  dir = {x:1,y:0};
  nextDir = {...dir};
  placeVo();
  score = 0;
  speed = 100;
  running = true;
  scoreEl.textContent = score;
  if(loopId) clearInterval(loopId);
  loopId = setInterval(gameLoop, speed);
}

function placeVo(){
  // Gera uma posição que não colida com a cobra
  while(true){
    const x = Math.floor(Math.random()*COLS);
    const y = Math.floor(Math.random()*ROWS);
    if(!snake.some(s=>s.x===x && s.y===y)){
      vo = {x,y};
      return;
    }
  }
}

function gameLoop(){
  // aplica próxima direção
  dir = nextDir;
  // calcula nova cabeça
  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
  // colisão com paredes: volta do outro lado (wrap)
  head.x = (head.x + COLS) % COLS;
  head.y = (head.y + ROWS) % ROWS;

  // colisão com o próprio corpo -> reinicia
  if(snake.some((s, i) => i>0 && s.x===head.x && s.y===head.y)){
    // game over
    running = false;
    clearInterval(loopId);
    flashGameOver();
    return;
  }

  snake.unshift(head);

  // se pegou o v
  if(head.x===vo.x && head.y===vo.y){
    score += 1;
    scoreEl.textContent = score;
    // a cada 3 pontos, acelera um pouco
    if(score % 3 === 0 && speed>40){
      speed = Math.max(40, speed - 8);
      clearInterval(loopId);
      loopId = setInterval(gameLoop, speed);
    }
    placeVo();
  } else {
    // caso normal, remove a cauda
    snake.pop();
  }

  draw();
}

function draw(){
  // fundo
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // desenha grade sutil
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  for(let x=0;x<=canvas.width;x+=TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
  for(let y=0;y<=canvas.height;y+=TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

  // desenha o 'v' (alvo) — representado por um ícone simples com texto "V"
  drawVo(vo.x, vo.y);

  // desenha a cobra (corpo)
  for(let i=snake.length-1;i>=0;i--){
    const s = snake[i];
    drawSegment(s.x, s.y, i===0);
  }
}

function drawSegment(gridX, gridY, isHead){
  const px = gridX * TILE;
  const py = gridY * TILE;

  if(isHead){
    // desenha cabeça de robô — um quadrado com olhos e antena
    ctx.save();
    ctx.translate(px + TILE/2, py + TILE/2);

    // corpo da cabeça
    ctx.fillStyle = '#a7d2ff';
    roundRect(ctx, -TILE/2+2, -TILE/2+2, TILE-4, TILE-4, 6, true, false);

    // face sombreada
    ctx.fillStyle = '#16324a';
    roundRect(ctx, -TILE/2+6, -TILE/2+10, TILE-12, TILE-12, 4, true, false);

    // olhos (dois LEDs)
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-8, -2, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(8, -2, 3, 0, Math.PI*2); ctx.fill();

    // pupilas
    ctx.fillStyle = '#0b1220';
    ctx.beginPath(); ctx.arc(-8, -2, 1.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(8, -2, 1.2, 0, Math.PI*2); ctx.fill();

    // antena
    ctx.strokeStyle = '#ffd97d'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(12, -TILE/2+6); ctx.lineTo(12, -TILE/2-6); ctx.stroke();
    ctx.fillStyle = '#ffd97d'; ctx.beginPath(); ctx.arc(12, -TILE/2-8, 4, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  } else {
    // corpo da cobra
    ctx.fillStyle = '#7fb1ff';
    roundRect(ctx, px+3, py+3, TILE-6, TILE-6, 4, true, false);
  }
}

function drawVo(gridX, gridY){
  const px = gridX * TILE;
  const py = gridY * TILE;
  // desenha um círculo com o texto V 
  ctx.save();
  ctx.translate(px + TILE/2, py + TILE/2);
  ctx.fillStyle = '#ffb7b7';
  ctx.beginPath(); ctx.arc(0,0, TILE/2 - 3, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#7b2b2b';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('V', 0, 0);
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  if (typeof stroke === 'undefined') stroke = true;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

// controles do teclado
window.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  if(k==='arrowup' || k==='w') setDir(0,-1);
  if(k==='arrowdown' || k==='s') setDir(0,1);
  if(k==='arrowleft' || k==='a') setDir(-1,0);
  if(k==='arrowright' || k==='d') setDir(1,0);
});

function setDir(x,y){
  // evita virar 180 graus
  if(dir.x===-x && dir.y===-y) return;
  nextDir = {x,y};
}

// clique para reiniciar
restartBtn.addEventListener('click', reset);

// efeito visual de Game Over
function flashGameOver(){
  let flashes = 0;
  const f = setInterval(()=>{
    ctx.fillStyle = flashes%2 ? 'rgba(255,40,40,0.12)' : 'rgba(0,0,0,0)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    flashes++;
    if(flashes>6){ clearInterval(f); setTimeout(reset, 700); }
  }, 120);
}

// touch controls simples (swipe)
let touchStart = null;
canvas.addEventListener('touchstart', e => { touchStart = e.touches[0]; });
canvas.addEventListener('touchend', e => {
  if(!touchStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.clientX;
  const dy = t.clientY - touchStart.clientY;
  if(Math.abs(dx) > Math.abs(dy)) setDir(dx>0?1:-1,0);
  else setDir(0, dy>0?1:-1);
  touchStart = null;
});

// inicia
reset();

</script>
</body>
</html>
